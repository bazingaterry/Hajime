

# **中山大学移动信息工程学院本科生实验报告**

## **（2015学年夏季学期）**

课程名称：**Data structures and algorithms**                         任课教师：**张子臻**

|  年级  |     14      |  专业   |     移动信息工程     |
| :--: | :---------: | :---: | :------------: |
|  学号  |  14353026   |  姓名   |      陈启聪       |
|  电话  | 13632278888 | Email | terry@32ph.com |
| 开始日期 | 2015.12.04  | 完成日期  |   2015.12.30   |

目录：

[TOC]

### 1. 实验题目

对英汉字典使用哈希表储存，探究不同哈希方式，不同储存方式，不同负载因子下，哈希表的性能的分析。



### 2. 实验目的

1. 了解哈希表的基本概念、优点、适用范围以及实现原理。
2. 了解不同哈希函数的实现方法。
3. 了解开放地址法和链地址法实现方式的差异和它们的优缺点。
4. 学会分析不同哈希表实现的性能，能从碰撞次数、程序运行的次数、程序运行时间等方面进行分析。



### 3. 程序设计

 `HashMap` 类为纯虚类，提供插入，查询，删除还有一系列统计接口，例如查询碰撞发生的次数和负载因子。 `HashMap` 实例化时，通过传入 `Hash` 函数的函数指针决定该哈希表的哈希函数。

`HashMap_OA` 类继承自 `HashMap` ，利用开放地址法储存数据，可以自定义发生冲突时探测地址的增量，可以很方便地进行线性探测、二次探测或三次探测等。

`Node` 和 `ListNode` 为模板类，是  `<key, value>` 形式的链表储存，提供插入、删除、查询等接口。本次实验中，key 与 value 的类型均为 `std::string`。

`HashMap_Chaining` 类继承自 `HashMap` ，利用链地址法储存数据，其链表的实现使用`ListNode<std::string, std::string>`。

`PeformanceAnalyze` 类用于统计函数运行时间，是 `HashMap` 的友元类，它的构造函数开始统计时间，析构函数结束统计，并将时间差加到 `HashMap` 的计数器中。

`HashMethod` 为不同哈希函数。



### 4. 程序运行与测试

数据采用随机数生成 ascii 码，长度为10。



由于输入输出数据量大，所以采用重定向的方式将标准输入输出重定向到文件，例如：

`$ ./main < testin.txt > testout.txt`



### 5. 实验数据与分析

*运行时间均是同一电脑运行 5 次取平均值。*

#### 哈希函数之间的比较

- 使用开放地址法二次探测。
- 哈希表大小为 2000000。
- 插入数据数据量为 1000000。

|   哈希函数    |   运行次数    |   冲突次数    |   运行时间    |
| :-------: | :-------: | :-------: | :-------: |
| AsciiHash | 741803968 | 740803968 | 138.475ms |
|  RSHash   |  1430275  |  430275   |  2.109ms  |
|  JSHash   |  1429663  |  429663   | 2.10362ms |
|  ELFHash  |  1431535  |  431535   | 2.18229ms |
|  DJBHash  |  1429095  |  429095   | 2.11032ms |
|  APHash   |  1429786  |  429786   | 2.10981ms |
|  PJWHash  |  1431535  |  431535   | 2.16102ms |

**由数据结果分析得，`AsciiHash` 由于是将各字母的 ascii 码相加，所以长度相同的英语单词 Hash 后的结果很容易出现冲突，可见 1000000 个数据，冲突次数有 740803968 次，冲突的概率为 99.87%，而其他 Hash 方法都有较好表现。在实际工程中，可以对数据进行抽样然后进行不同的 Hash，统计冲突的概率，然后可以选择最优的 Hash 函数。**



#### 开放地址法探测次数的比较

- 使用 RSHash 哈希函数。
- 哈希表大小为 4000000。
- 插入数据数据量为 1000000，负载因子为 25%。

| 探测次数 |  运行次数   |  冲突次数  |   运行时间    |
| :--: | :-----: | :----: | :-------: |
|  1   | 1500767 | 500767 | 1.97908ms |
|  2   | 1430275 | 430275 | 1.95764ms |
|  3   | 1160246 | 160246 | 1.96104ms |
|  4   | 1160195 | 160195 | 1.95931ms |

**由数据结果分析得，线性探测由于容易造成数据堆积，多次探测有利于数据分散，但探测次数 >= 2 时对性能影响不大。**



#### 开放地址法与链地址法的比较

- 使用 RSHash 哈希函数。
- 哈希表大小为 2000000。
- 开放地址法使用二次探测。
- 插入数据量为 1000000。
- 进行 2000000 次查询，其中 50% 查询成功。

| 储存方法  |    插入时间    |   查询时间    |
| :---: | :--------: | :-------: |
| 开放地址法 | 1.89588ms  | 4.08635ms |
| 链地址法  | 0.815243ms | 1.45723ms |

**由数据结果分析得，链地址法由于处理冲突更加高效，插入和查询性能均优于开放地址法。**



#### 哈希表不同容量的比较

##### 开放地址法

- 使用 RSHash 哈希函数。
- 使用二次探测。
- 插入数据量为 1000000。
- 进行 2000000 次查询，其中 50% 查询成功。

|    容量    | 负载因子  |  碰撞次数   |   插入时间    |   查询时间    |
| :------: | :---: | :-----: | :-------: | :-------: |
| 1010000  | 99.0% | 4224416 | 2.6671ms  | 39.765ms  |
| 1100000  | 90.9% | 1881180 | 2.20615ms | 7.93033ms |
| 1500000  | 66.7% | 737370  | 2.01383ms | 4.8574ms  |
| 3000000  | 33.3% | 235046  | 1.94588ms | 4.29446ms |
| 5000000  | 20.0% | 122057  | 1.93773ms | 4.20194ms |
| 10000000 | 10.0% |  55031  | 1.93735ms | 4.16481ms |

**由数据结果分析得，过高的负载因子会使开放地址法性能下降，过低的负载因子会浪费大量的内存空间而性能提升不大，尽量让负载因子保持在 60% - 70% 有利于平衡空间和时间。在极端情况下（例如负载因子超过 99% ），插入性能会极大下降，程序难以找到适合空位把数据插入，而查询时需要考虑到查询不存在的键值的情况，需要限制探测的次数，所以查询失败率也大大提高。**



##### 链地址法

- 使用 RSHash 哈希函数。
- 插入数据量为 1000000。
- 进行 2000000 次查询，其中 50% 查询成功。

|    容量    | 负载因子  |    插入时间    |   查询时间    |
| :------: | :---: | :--------: | :-------: |
|  100000  | 1000% | 1.61489ms  | 3.80706ms |
|  50000   | 500%  | 0.904735ms | 1.70737ms |
| 1000000  | 100%  | 0.885974ms | 1.69135ms |
| 3000000  | 33.3% | 0.876999ms | 1.57356ms |
| 5000000  | 20.0% | 0.882241ms | 1.58971ms |
| 10000000 | 10.0% | 0.882666ms | 1.58979ms |

**由数据结果分析得，由于数据在链表的头部插入，负载因子并不会对链地址法的插入性能产新太大影响。但由于查询的最坏情况需要遍历整个链表，所以过高负载因子会对查询性能有影响。**



#### 哈希表删除性能比较

##### 开放地址法

- 使用 RSHash 哈希函数。
- 使用二次探测，容量 2000000。
- 插入数据为英文单词，数据量为 3209。
- 随机删除 50% 数据，然后进行 6418 次查询，其中 50% 查询成功。

##### 链地址法

- 使用 RSHash 哈希函数。
- 容量 2000000。
- 插入数据为英文单词，数据量为 3209。
- 随机删除 50% 数据，然后进行 6418 次查询，其中 50% 查询成功。

| 储存方法  |    插入时间    |    删除时间    |  删除后查询时间   |
| :---: | :--------: | :--------: | :--------: |
| 开放地址法 | 0.005486ms | 0.002434ms | 0.00832ms  |
| 链地址法  | 0.002079ms | 0.001016ms | 0.002716ms |

**由数据结果分析得，过多的删除操作，会使得开放地址法在较低的负载因子下也会有很差的性能表现，而链地址法并没有这个缺陷。**



#### 不同数据量的比较

##### 开放地址法

- 使用 RSHash 哈希函数。
- 使用二次探测，容量80000。

|  数据量   |    插入时间    |
| :----: | :--------: |
|  3000  | 0.005525ms |
|  8000  | 0.014702ms |
| 10000  | 0.018799ms |
| 50000  | 0.093265ms |
| 100000 | 0.202097ms |

##### 链地址法

- 使用 RSHash 哈希函数。
- 容量120000。

|  数据量   |    插入时间    |
| :----: | :--------: |
|  3000  | 0.002365ms |
|  8000  | 0.006154ms |
| 10000  | 0.007531ms |
| 50000  | 0.038654ms |
| 100000 | 0.081886ms |

**由数据结果分析得，链地址法的性能优于开放地址法，而且随着数据量增大，差距越大。**



### 6. 实验总结与心得

总的来说，链地址法的性能要优于开放地址法的性能，尤其是负载因子较高时候的插入性能。如果想对链地址法进行优化的话，我自己想到的方法是可以将线性结构的链表换成树形结构的二叉查找树，例如是红黑树或是 AVL 树等，这样可以将链表查找的时间复杂度从 `O(N)` 下降到 `O(log N)`。



### 附录、提交文件清单

`/src/*` 